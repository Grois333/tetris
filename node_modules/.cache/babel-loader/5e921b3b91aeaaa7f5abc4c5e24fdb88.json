{"ast":null,"code":"export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20; //Create the Stage of rows of cells (Array in an Array)\n\nexport const createStage = () => Array.from(Array(STAGE_HEIGHT), () => new Array(STAGE_WIDTH).fill([0, 'clear']) // 0 is a clean cell, clear is that no tetrominos collision\n); //Check for collisions (out of the stage and with other Tetrominos)\n\nexport const checkCollision = (player, stage, {\n  x: moveX,\n  y: moveY\n}) => {\n  //Loop through the tetromino\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we are on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if ( // 2. Check that our move is inside the game areas height (y)\n        // We shouldn't go through the bottom of the play area\n        !stage[y + player.pos.y + moveY] || // 3. Check that our move is inside the game areas width (x)\n        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] || // 4. Check that the cell we are moving to isn't se to clear\n        stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear') {\n          return true;\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/home/isaac/Documents/Developers Institute/Exercises/tetris/src/gameHelpers.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","x","moveX","y","moveY","tetromino","length","pos"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,EAApB;AAEP,OAAO,MAAMC,YAAY,GAAG,EAArB,C,CAEP;;AACA,OAAO,MAAMC,WAAW,GAAG,MACzBC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,EAAgC,MAC9B,IAAIE,KAAJ,CAAUH,WAAV,EAAuBK,IAAvB,CAA4B,CAAC,CAAD,EAAI,OAAJ,CAA5B,CADF,CAC4C;AAD5C,CADK,C,CAMP;;AACA,OAAO,MAAMC,cAAc,GAAG,CAACC,MAAD,EAASC,KAAT,EAAgB;AAAEC,EAAAA,CAAC,EAAEC,KAAL;AAAYC,EAAAA,CAAC,EAAEC;AAAf,CAAhB,KAA2C;AAEvE;AACA,OAAI,IAAID,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGJ,MAAM,CAACM,SAAP,CAAiBC,MAApC,EAA4CH,CAAC,IAAI,CAAjD,EAAmD;AACjD,SAAI,IAAIF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBG,MAAvC,EAA+CL,CAAC,IAAI,CAApD,EAAsD;AAErD;AACC,UAAGF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBF,CAApB,MAA2B,CAA9B,EAAgC;AAE9B,aACA;AACA;AACA,SAACD,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAN,IAEA;AACA,SAACJ,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CAAgCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KAAnD,CAHD,IAKA;AACAF,QAAAA,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CAAgCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KAAnD,EAA0D,CAA1D,MAAiE,OATjE,EAUC;AAEC,iBAAO,IAAP;AAED;AACF;AAEF;AACF;AAEF,CA7BM","sourcesContent":["export const STAGE_WIDTH = 12;\n\nexport const STAGE_HEIGHT = 20;\n\n//Create the Stage of rows of cells (Array in an Array)\nexport const createStage = () =>\n  Array.from(Array(STAGE_HEIGHT), () =>\n    new Array(STAGE_WIDTH).fill([0, 'clear']) // 0 is a clean cell, clear is that no tetrominos collision\n);\n\n\n//Check for collisions (out of the stage and with other Tetrominos)\nexport const checkCollision = (player, stage, { x: moveX, y: moveY }) => {\n\n  //Loop through the tetromino\n  for(let y = 0; y < player.tetromino.length; y += 1){\n    for(let x = 0; x < player.tetromino[y].length; x += 1){\n\n     // 1. Check that we are on an actual Tetromino cell\n      if(player.tetromino[y][x] !== 0){\n\n        if(\n        // 2. Check that our move is inside the game areas height (y)\n        // We shouldn't go through the bottom of the play area\n        !stage[y + player.pos.y + moveY] ||\n\n        // 3. Check that our move is inside the game areas width (x)\n        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n\n        // 4. Check that the cell we are moving to isn't se to clear\n        stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear'\n       ) {\n\n          return true;\n\n        }\n      }\n\n    }\n  }\n\n};\n"]},"metadata":{},"sourceType":"module"}